@import Main._
@val tests = wd/'fastparse/'shared/'src/'test/'scala/'fastparse
@val main = wd/'fastparse/'shared/'src/'main/'scala/'fastparse

@sect{Byte Parsers}
    @p
        While FastParse was originally designed to parse @hl.scala{String}s,
        it also provides a @code{fastparse.byte} package that allows parsing
        of @hl.scala{Array[Byte]}s (or @hl.scala{Iterator[Array[Byte]]}s) into
        structured data.

    @p
        Here is a small example parser that parsers an imaginary struct-like
        format: a fixed header, two fixed-length fields (big-endian), one
        @lnk("0-terminated C-style string", "https://en.wikipedia.org/wiki/String_(computer_science)#Null-terminated"),
        and one @lnk("length-prefixed", "https://en.wikipedia.org/wiki/String_(computer_science)#Length-prefixed")
        binary blob up to 65535 bytes
        long (the max size of the UInt16 length field):


    @hl.ref(tests/"ByteTests.scala", Seq("'splash", ""), "val bytes =")

    @p
        As you can see it has the same underlying structure as previous
        @sect.ref{Basic} string-parsers: it uses @code{~} to @sect.ref{Sequence}
        parsers, @hl.scala{!} to @sect.ref{Capture} sections of bytes,
        @sect.ref{Map}, to turn them into useful structures, etc..

    @p
        Here is how we use it:

    @hl.ref(tests/"ByteTests.scala", Seq("'splash", "", "val bytes ="))

    @p
        About the same as what you would expect, if you had used FastParse
        to parse textual Strings.

    @p
        While @code{fastparse.byte} is similar to the string-parsing
        API, there are some new primitives that are specific to byte parsers,
        and some existing primitives that are named slightly differently.

    @sect{Byte Helpers}
        @p
            Apart from providing an equivalent API for byte parsing, FastParse's
            byte-parsers also provide some helper functions for conveniently dealing
            with binary blobs.

        @sect{BS}
            @hl.ref(tests/"ByteTests.scala", Seq("'bs", ""))
            @p
                This is a shorthand for @code{Array[Byte](...)} that is shorter
                and saves you a bunch of annoying @code{.toByte} calls.

        @sect{hexBytes}
            @hl.ref(tests/"ByteTests.scala", Seq("'hexBytes", ""))
            @p
                Another shorthand for @code{Array[Byte](...)}, that lets you
                pass in lower-case hexadecimal bytes.

        @sect{prettyBytes}
            @hl.ref(tests/"ByteTests.scala", Seq("'prettyBytesBare", ""))
            @p
                This function converts a byte array into a nicely-readable
                hex-grid. This makes it easier for you to look for byte-ranges,
                count offsets, and that sort of thing. By default, it only shows
                the first 8 rows of the byte array. You can specify
                @code{markers} if you want to view portions of the byte
                array around other indices, and @code{prettyBytes} will add
                markers so you can see exactly the spots you specified:

            @hl.ref(tests/"ByteTests.scala", Seq("'prettyBytesMarker", ""))

    @sect{Byte-Specific Parsers}
        @p
            Many byte formats heavily use the concept of a fixed width "word"
            or "double"-word, always a multiple-of-two bytes, and usually
            parsed into the corresponding @lnk("twos-complement",
            "https://en.wikipedia.org/wiki/Two%27s_complement") integer or
            @lnk("floating point", "https://en.wikipedia.org/wiki/Floating_point")
            number. @code{fastparse.byte} provides built in support for these.

        @sect{WordN}
            @hl.ref(tests/"ByteTests.scala", Seq("'words", ""))
            @p
                @code{fastparse.byte} provides convenient parsers for the common
                case of parsing 1, 2, 4, and 8-byte "words". These parsers do
                not capture any result, but merely consume the bytes and move
                the index forward.

            @p
                If you want to capture the bytes as an
                @code{Array[Byte]}, use the @code{.!} to @sect.ref{Capture}
                them. If you want to capture them as various sorts of
                integers or numbers, use one of the @sect.ref{IntN} parsers
                listed below

        @sect{IntN}
            @hl.ref(tests/"ByteTests.scala", Seq("'int8", ""))

            @p
                FastParse provides parsers to capture single bytes and return
                them, as signed @code{Byte}s. An unsigned versions of the parser
                is available, that lifts the result into a @code{Short} since
                the higher-values of an unsigned byte (e.g. @code{128}) cannot
                fit into a signed @code{Byte}, which maxes out at positive
                @code{127}.

            @hl.ref(tests/"ByteTests.scala", Seq("'uint8", ""))

            @val endian = lnk("endian", "https://en.wikipedia.org/wiki/Endianness")
            @p
                Apart from capturing @code{Byte}s, FastParse also provides
                parsers which capture @code{Short}s, @code{Int}s and @code{Long}s.
                These come in both big-@endian (@code{BE} below) and little-@endian
                (@code{LE}) versions:

            @hl.ref(tests/"ByteTests.scala", Seq("'endian", ""))

            @p
                As well as signed and un-signed versions

            @hl.ref(tests/"ByteTests.scala", Seq("'unsignedEndian", ""))

            @p
                The unsigned versions of all these parsers max out at
                @code{Int32}; this is because there is no primitive type in
                Scala that can hold the higher-values of an unsigned 64-bit
                @code{Long}.

            @p
                Note the difference between @code{LE} and @code{BE} versions of the
                @code{IntN} parsers; there are
                @lnk("two standards of ordering bytes", "https://en.wikipedia.org/wiki/Endianness"),
                so you have to pick which one you want to use. You can also @hl.scala{import LE._}
                or @hl.scala{import BE._} if the endian-ness is the same throughout
                your parser, and then use @code{Int16}/@code{Int32}/@code{Int64} directly.
                Typically, big-endian formats are common in networking applications
                (e.g. UDP packets) while little-endian formats are common in operating
                systems and micro-processors.

        @sect{FloatN}
            @hl.ref(tests/"ByteTests.scala", Seq("'floats", ""))

            @p
                Apart from parsing integers using @sect.ref{IntN},
                @code{fastparse.byte} also contains parsers for common floating
                point numbers. These come in both big-endian/little-endian
                and 32/64-bit versions.



    @sect{Equivalent Byte Parsers}
        @p
            Apart from the byte-specific parsers mentioned above, Fastparse's
            byte-parsing API has many of the

        @ul
            @li
                @hl.scala{BS} or @hl.scala{ByteSeq} is an alias for
                @hl.scala{Array[Byte]}, and is used for parsing hard-coded
                sequences of bytes. This is equivalent to the most basic
                @sect.ref("Basic", "literal string parsers") in Fastparse's
                string-parsing API
            @li
                @sect.ref{AnyChar}/@code{AnyChars} becomes @hl.scala{AnyByte}/@code{AnyBytes}
            @li
                @sect.ref{CharPred} becomes @hl.scala{BytePred}
            @li
                @sect.ref{CharIn} becomes @hl.scala{ByteIn}
            @li
                @sect.ref{CharsWhile} becomes @hl.scala{BytesWhile}
            @li
                @hl.scala{StringIn} becomes @hl.scala{SeqIn}

        @p
            For example, here is a small example using @hl.scala{BS}
            primitives and @hl.scala{AnyByte}

        @hl.ref(tests/"ByteTests.scala", Seq("'anybyte", ""))

        @p
            Apart from the changes listed above, FastParse's byte-parsing API works about
            same as it's string-parsing API. @sect.ref{Sequence}, @sect.ref{Repeat},
            @sect.ref{Optional}, @sect.ref{Either}, @sect.ref{Capture}, @sect.ref{Map},
            @sect.ref{FlatMap}, @sect.ref{Filter} and many other operators all work
            the same when parsing bytes as they do when parsing strings:

        @hl.ref(tests/"ByteTests.scala", Seq("'splash", ""))

        @p
            The process of @sect.ref{Debugging Parsers}, @sect.ref{Using Cuts}
            or @sect.ref{Using Log} to figure out what is going on, is all identical
            between FastParse's byte-parsing and string-parsing APIs.


    @sect{Example Byte Parsers}

        @sect{UDP Packets}
            @p
                This is an example @lnk("UDP Datagram", "https://en.wikipedia.org/wiki/User_Datagram_Protocol")
                packet-parser implemented using FastParse's byte-parsing api:

            @hl.ref(tests/"ByteTests.scala", Seq("'udp", ""), "val bytes =")

            @p
                Here's how to use it:

            @hl.ref(tests/"ByteTests.scala", Seq("'udp", "val bytes ="))

        @sect{BmpParser}
            @p
                @hl.scala{BmpParser} is a good example of a slightly more complex byte parser:
                a parser for @lnk("Bitmap image files", "https://en.wikipedia.org/wiki/BMP_file_format").
                It's not small, but structure is pretty simple. It does not
                support the full breadth of the Bitmap format, but it supports
                enough to parse many common images.
            @p
                Like all other FastParse parsers, FastParse's Byte parsers all
                run in the browser via Scala.js, and so does BmpParser! Here
                we have a live demo: upload a bitmap file, and will parse it
                and print out some simple metadata (width, height, etc.):

            @div(id := "bmpdiv")
            @script(raw("""demo.DemoMain().bmp(document.getElementById("bmpdiv"))"""))
            @i
                If you haven't any bmp around, you can download classic
                @a("lena", href:="https://raw.githubusercontent.com/lihaoyi/fastparse/master/fastparse/jvm/src/test/resources/lena.bmp").

            @sect{BmpParser Walkthrough}
                @p
                    Here, we'll walk through the implementation of BmpParser,
                    which should give you a taste of how FastParse's
                    @sect.ref{Byte Parsers} work in general.
                @hl.scala{import fastparse.ByteUtils.LE._}

                @p
                    First of all we import package for Little-Endian support, because BMP format use it.

                @hl.ref(tests/"BmpTests.scala", "val bmp")

                @p
                    Bmp file consists of two headers (file header and info header) and pixels in rows with padding,
                    the difficulties are that there are several versions of headers and the parser should distinct them and
                    process them correctly, and that the size and padding of rows in bmp file depends on information from header.

                @hl.ref(tests/"BmpTests.scala", "val fileHeader", "def bmpRow")

                @p
                    The first problem is reflected in similar parsers describing 5 versions of info header
                    (@hl.scala{v2HeaderPart}, @hl.scala{v2Header}, @hl.scala{v3HeaderPart}, @hl.scala{v3Header}...).

                @hl.ref(tests/"BmpTests.scala", "def bmpRow", "val bmp")

                @p
                    The second problem in the @hl.scala{bmpRow} function that computes the parameters of row and creates parser on a fly.

                @p
                    Note also few tricks for parsing binary data.
                @ul
                    @li
                        @b
                            Most of main elements in bmp format has very simple and plain structure. @br
                         For instance @hl.scala{fileHeader} and @hl.scala{infoHeaderPart}
                         are just sequences of @hl.scala{AnyDwordI} or @hl.scala{AnyWordI}
                    @li
                        @b
                            The extensive usage of @hl.scala{.rep(exactly=...)}.@br
                        This is due to the fact that many binary formats depends on constant-sized blocks
                        and the easiest and fastest method to parse them is to write @hl.scala{.rep(exactly=...)}.
                    @li
                        @b
                            The same extensive usage of @hl.scala{for}-comprehensions.@br
                        @hl.scala{for}-comprehensions (equivalent to @hl.scala{flatMap})
                        allow to retrieve data from one parser and pass it to the next.
                        The most popular and primitive example is dynamic-sized array with
                        length written at the beginning. Similar algorithm is used in the
                        @hl.scala{bmp} when header information is passed to the @hl.scala{bmpRow}
                        that returns new parser for row in this particular bmp file.

        @sect{MidiParse}
            @p
                MidiParse is an example byte-parser written using FastParse, for
                parsing @lnk("MIDI music files", "https://en.wikipedia.org/wiki/MIDI").
                Like all FastParse parsers, it compiles to Javascript via Scala.js and
                can run in the browser: below is a small widget that uses MidiParse to
                parse, analyze and play any Midi file you upload use Keith Horwood's
                @lnk("AudioSynth", "https://github.com/keithwhor/audiosynth") Javascript
                library.

            @div(id := "mididiv")
            @script(src:="Audio.js", `type`:="text/javascript")
            @script(raw("""demo.DemoMain().midiparser(document.getElementById("mididiv"))"""))

            @p
                If you don't have any midi files lying around, perhaps you could
                try one of these:

            @ul
                @for(name <- Seq("canon.mid", "go.mid", "tonghua.mid"))
                    @li
                        @lnk(name, s"https://raw.githubusercontent.com/lihaoyi/fastparse/master/fastparse/jvm/src/test/resources/$name")

            @p
                If you wish, you can also check out this project and run
                @code{sbt "fastparseJVM/test:run go.mid"} from the command line
                to play the same MIDI file using the same parser, but running on
                Scala-JVM and using the JVM's MIDI player rather than the browser's.
                In general, the JVM player is much more robust than the Web player:
                the Web player doesn't know how to handle changes in pitch bend,
                polyphonic pressure, channel pressure or controller, and plays
                all notes as a single piano-like instrument

            @p
                MidiParse comprises about 50 lines of @hl.scala{case class}es that
                define the structure of the midi file, and another 140 lines of
                FastParse code for parsing the MIDI from binary input:

            @ul
                @li
                    @a("MidiParse Source", href:="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MidiParse.scala")

            @p
                MidiParse illustrates many of the quirks of writing a parser for
                a real-world binary format:

            @ul
                @li
                    How to parse various sorts of bit-packed integers: 8-bit,
                    16-bit, or 32-bit signed and unsigned integers (e.g. @code{UInt8}).
                    Even more obscure things like the 24-bit integer used to
                    store the @code{Tempo} of the music, or the variable-length
                    @code{varInt} parser keeps consuming individual bytes
                    until it finds one whose high-order bit is set, and then
                    concats them all into one variable-length integer.
                @li
                    @code{varString} and @code{varByte} parsers are a common
                    case of using @sect.ref{FlatMap} to parse a variable-length
                    data-field whose length is defined up-front
                @li
                    @code{midiEvent} and @code{metaEvent} show how to switch
                    on a single byte upfront and use that to decide how to
                    continue parsing a particular item, using
                    @sect.ref{FlatMap}/@hl.scala{for}-comprehensions
                @li
                    How to use @sect.ref{Filter} to narrow down the sort of
                    input a parser can parse, e.g. to narrow a
                    @hl.scala{Int8: Parser[Byte]} into a parser that only
                    accepts non-negative bytes

            @p
                Other than these quirks, the majority of the parser is
                relatively straightforward FastParse code.


        @sect{ClassParser}
            @p
                The other example byte-parser that FastParse provides is @hl.scala{ClassParser}.
                It's quite a complex parser that process @code{.class} files with java bytecode,
                and parses them into a simple structured format. You can see the code here:

            @ul
                @li
                    @a("ClassParse", href:="https://github.com/lihaoyi/fastparse/tree/master/classparse/shared/src/main/scala/classparse")
            @p
                ClassParse is able to retrieve almost full information about given
                class including all methods, fields, subclasses, code and pack it
                into the convenient AST. On the similarity with other big parsers
                it has good set of unit-tests with tests which compile real projects
                from github (joda-time, junit4, jenkins and etc.) and check each built file.

            @p
                Like all FastParse parsers, ClassParse compiles to Javascript using
                Scala.js and can run in the browser. Below is a short demo of ClassParse
                in action: upload any @code{.class} file full of Java byte code, and it
                will parse it and print out the names and signatures of all fields and
                methods define in that class:

            @div(id := "clssdiv")
            @script(raw("""demo.DemoMain().clss(document.getElementById("clssdiv"))"""))

            @p

                If you haven't any .class files around, you can download some examples
                to try:
            @ul
                @val files = Seq(
                    "Book.java", "Book.class",
                    "Book2.java", "Book2.class",
                    "CodeTest.java", "CodeTest.class"
                )
                @for(file <- files)
                    @li
                        @a(file, href:=s"https://github.com/lihaoyi/fastparse/raw/master/fastparse/shared/src/test/resources/$file")

            @p
                You can download the classfiles and directly try them in this
                demo, or you can download the sources and compile them yourself
                with @code{javac} before uploading the generated class file.
